---
title: "Kern County Fields Through Time"
author: "Iris Foxfoot"
date: "1/17/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(tidyverse)
library(here)
library(raster)
library(tmap)
library(janitor)
```

```{r}
#read in data
#must have the following file path in working directory: data/kernfields/kernYEAR/kernYEAR.shp

#create list of years
kern_field_years <- c(2016:2019)

#loop through read in process
for (i in kern_field_years) {
  filename <- paste0("kernfields_", i)
  wd <- paste0("data/kernfields/kern", i, "/kern", i, ".shp")
  assign(filename, read_sf(wd))
}

#read in kern county shapefile
kern_county <- read_sf(here("data", "Kern_County_Boundary", "Kern_County_Boundary.shp")) %>% 
  st_transform(crs = crs(kernfields_2016))

#create processing loop. This loop will do the following
#transform and clean geometries
#select permitsiteID
#extract SSURGO soil quality
#rbind
#create unique ID
#create year column

```

```{r}
#clean names, make sure each polygon has same number of rows

kern_16_clean <- kernfields_2016 %>% 
  clean_names() %>% 
  mutate(symbol = NA) %>% 
  mutate(comm_code = NA) %>% 
  mutate(year = 2016)

kern_17_clean <- kernfields_2017 %>% 
  clean_names() %>% 
  mutate(year = 2017)

kern_18_clean <- kernfields_2018 %>% 
  clean_names() %>% 
  mutate(year = 2018)

kern_19_clean <- kernfields_2019 %>% 
  clean_names()  %>% 
  mutate(year = 2019)


#bind all rows,dissolve (union) boundaries
kern_binded <- rbind(kern_16_clean, kern_17_clean, kern_18_clean, kern_19_clean) %>% 
  st_union()

#plot
plot(st_geometry(kern_binded))

#write to sf
#st_write(kern_binded, here("data", "shapefiles_written", "unioned_fields_20162019"), driver = "ESRI Shapefile")

```

```{r}
#crop

#select region (based off of farmer)
kern_subset <- kern_19_clean %>% 
  filter(agent == "McMANUS/WILSON,MICHELE/AARIN")

plot(kern_subset["p_status"])

#crop
kern_19_crop <- st_crop(kern_19_clean, kern_subset)

plot(kern_19_crop["p_status"])

kern_18_crop <- st_crop(kern_18_clean, kern_subset)

kern_county_crop <- st_crop(kern_county, kern_subset)

plot(kern_county_crop["FID"])
```

```{r}
# Convert to tibble for a dplyr full join on the geometry column.
kern1819_intersect <- full_join(as_tibble(kern_19_crop), as_tibble(kern_18_crop), by = "geometry")

kern_1819_sf <- st_as_sf(kern1819_intersect)

tmap_mode("view")

tm_shape(kern_1819_sf) +
  tm_polygons(c("pmt_site.x", "pmt_site.y"), legend.show = FALSE)
```

```{r}
tm_shape(kern_18_crop) +
  tm_polygons("pmt_site", legend.show = FALSE)
```

```{r}
tm_shape(kern_19_crop) +
  tm_polygons("pmt_site", legend.show = FALSE)
```

```{r}

plot(st_geometry(kern_19_crop), main = "2019")
plot(st_geometry(kern_18_crop), main = "2018")
plot(st_geometry(kern_1819_sf), main = "Intersect")
```

```{r}
library(stampr)
library(sp)
library(smoothr)

#rbind inputs, create ID column
croped_fields_binded <- rbind(kern_18_crop, kern_19_crop) %>% 
  st_make_valid() %>% 
  rownames_to_column(var="ID")

#conver to spatial
cropped_sp <- as(croped_fields_binded, "Spatial")

#use the stamp function to assess space-time change
stamp_test <- stamp.multichange(cropped_sp, changeByField = T, changeField = "year", dc = 0, distance = TRUE, direction = F)

#drop geometry "crumbs"
#stamp_test_crumbs <- drop_crumbs(stamp_test, threshold = 1, drop_empty = T)

#convert back to sf
stamp_test_sf <- st_as_sf(stamp_test) %>% 
  st_make_valid()

head(stamp_test_sf)

#task is somewhat computationally intensive...write to shapefile after

#st_write(stamp_test_sf, here("data", "shapefiles_written", "stamp_test.shp"), driver = "ESRI Shapefile")
```

```{r}
#THIS APPEARS TO WORK...NEED TO DROP CRUMBS
plot(st_geometry(kern_19_crop), main = "2019")
plot(st_geometry(kern_18_crop), main = "2018")
plot(st_geometry(stamp_test_sf), main = "Stamp_test")

library(tmap)

tmap_mode("view")

tm_shape(stamp_test_sf) +
tm_polygons("GROUP")
```

STAMP interp

ID1 Polygon ID from T1 polygons; NA if it did not exist,
ID2 Polygon ID from T2 polygons; NA if it did not exist,
LEV1 Level 1 STAMP designation,
LEV2 Level 2 STAMP designation,
LEV3 Level 3 STAMP designation,
LEV4 Level 4 STAMP designation,
GROUP Group ID signifying group membership,
AREA Polygon area in appropriate areal units,
-- (optional) Additional columns from directional analysis if direction = TRUE,
-- (optional) Additional columns from distance analysis if distance = TRUE,


STAMP events are reported at four levels of increasing complexity:
LEV1 – disappearance (DISA), stable (STBL), and generation (GENA);
LEV2 – disappearance (DISA), contraction (CONT), stable (STBL), expansion (EXPN), and generation
(GENR);
LEV3 – disappearance (DISA), T1 displacement (DISP1), convergence (CONV), concentration (CONC),
contraction (CONT), stable (STBL), expansion (EXP), fragmentation (FRAG), divergence (DIV), T2 displacement (DISP2), and generation (GENR);
LEV4 – LEV4 is different from other levels. It is used to identify those groups where union (UNION),
division (DIVISION), and both union and division (BOTH) events occur. 




