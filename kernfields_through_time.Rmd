---
title: "Kern County Fields Through Time"
author: "Iris Foxfoot"
date: "1/17/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
```

```{r get_packages}
knitr::opts_chunk$set(echo = TRUE)
library(sf) #for polygons
library(tidyverse) #for data wrangling
library(here) #for file paths
library(raster) #for rasters
library(fasterize) #for making rasters
library(tmap) #for interactive maps
library(janitor) #for cleaning names
library(stampr) #for space time analysis
library(sp) #spatial polygons, required for stampr to work
library(smoothr) #drops slivers
```

# Introduction

# Read in field data and wrangle it

In this section we read in the soil data and wrangle it such that the end product is a single dataframe containing shapefiles for fields in all years. We also need to add a unique ID column and a year column. 

```{r field_data_wrangling}
#read in kern data
#must have the following file path in working directory: data/kernfields/kernYEAR.shp

#create list of years
kern_field_years <- c(2005:2019)

#loop through read-in process
for (i in kern_field_years) {
  filename <- paste0("kernfields_", i)
  wd <- paste0("data/kernfields/kern", i, ".shp")
  assign(filename, read_sf(wd))
}

#loop through listed sf objects and tidy
fields_cleaned_list <- lapply(mget(sprintf("kernfields_%d", 2005:2019)), 
                 function(x) 
                   {
                   
                   clean_names(x) %>%
                     st_make_valid() %>% 
                     st_transform(crs = "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs") %>% 
                     dplyr::select(permit,
                                   permittee,
                                   pmt_site,
                                   comm,
                                   s_status,
                                   p_status,
                                   acres,
                                   dt_act)
                   
                     }
                 )


#rbind inputs
all_fields_binded <- do.call(rbind, fields_cleaned_list) %>% 
  st_make_valid()

#make id column, get year
all_fields <- all_fields_binded%>% 
  st_make_valid() %>% 
  rownames_to_column(var="ID") %>% 
  mutate(year = lubridate::year(dt_act)) %>% 
  dplyr::select(-dt_act)

#recast as multipolygon
all_fields <- st_cast(all_fields, "MULTIPOLYGON")

#convert to spatial
all_fields_sp <- as(all_fields, "Spatial")
```

```{r}

#use the stamp function to assess space-time change
stamp_test <- stamp.multichange(all_fields_sp, changeByField = T, changeField = "year", dc = 0, distance = F, direction = F)

#drop geometry "crumbs"
#stamp_test_crumbs <- drop_crumbs(stamp_test, threshold = 1, drop_empty = T)

#convert back to sf
stamp_test_sf <- st_as_sf(stamp_test) %>% 
  st_make_valid()

#write shapefile
st_write(stamp_test_sf, here("data", "shapefiles_written", "stamp_test_all_fields"), driver = "ESRI Shapefile")
```

```{r}
#clean names, make sure each polygon has same number of rows

kern_16_clean <- kernfields_2016 %>% 
  clean_names() %>% 
  mutate(symbol = NA) %>% 
  mutate(comm_code = NA) %>% 
  mutate(year = 2016)

kern_17_clean <- kernfields_2017 %>% 
  clean_names() %>% 
  mutate(year = 2017)

kern_18_clean <- kernfields_2018 %>% 
  clean_names() %>% 
  mutate(year = 2018)

kern_19_clean <- kernfields_2019 %>% 
  clean_names()  %>% 
  mutate(year = 2019)


#bind all rows,dissolve (union) boundaries
kern_binded <- rbind(kern_16_clean, kern_17_clean, kern_18_clean, kern_19_clean) %>% 
  st_union()

#plot
plot(st_geometry(kern_binded))

#write to sf
#st_write(kern_binded, here("data", "shapefiles_written", "unioned_fields_20162019"), driver = "ESRI Shapefile")

```

```{r}
#crop

#select region (based off of farmer)
kern_subset <- kern_19_clean %>% 
  filter(agent == "McMANUS/WILSON,MICHELE/AARIN")

plot(kern_subset["p_status"])

#crop
kern_19_crop <- st_crop(kern_19_clean, kern_subset)

plot(kern_19_crop["p_status"])

kern_18_crop <- st_crop(kern_18_clean, kern_subset)

kern_county_crop <- st_crop(kern_county, kern_subset)

plot(kern_county_crop["FID"])
```

```{r}
# Convert to tibble for a dplyr full join on the geometry column.
kern1819_intersect <- full_join(as_tibble(kern_19_crop), as_tibble(kern_18_crop), by = "geometry")

kern_1819_sf <- st_as_sf(kern1819_intersect)

tmap_mode("view")

tm_shape(kern_1819_sf) +
  tm_polygons(c("pmt_site.x", "pmt_site.y"), legend.show = FALSE)
```

```{r}
tm_shape(kern_18_crop) +
  tm_polygons("pmt_site", legend.show = FALSE)
```

```{r}
tm_shape(kern_19_crop) +
  tm_polygons("pmt_site", legend.show = FALSE)
```

```{r}

plot(st_geometry(kern_19_crop), main = "2019")
plot(st_geometry(kern_18_crop), main = "2018")
plot(st_geometry(kern_1819_sf), main = "Intersect")
```

```{r}
library(stampr)
library(sp)
library(smoothr)

#rbind inputs, create ID column
croped_fields_binded <- rbind(kern_18_crop, kern_19_crop) %>% 
  st_make_valid() %>% 
  rownames_to_column(var="ID")

#conver to spatial
cropped_sp <- as(croped_fields_binded, "Spatial")

#use the stamp function to assess space-time change
stamp_test <- stamp.multichange(cropped_sp, changeByField = T, changeField = "year", dc = 0, distance = F, direction = F)

#drop geometry "crumbs"
#stamp_test_crumbs <- drop_crumbs(stamp_test, threshold = 1, drop_empty = T)

#convert back to sf
stamp_test_sf <- st_as_sf(stamp_test) %>% 
  st_make_valid()

head(stamp_test_sf)

#task is somewhat computationally intensive...write to shapefile after

#st_write(stamp_test_sf, here("data", "shapefiles_written", "stamp_test.shp"), driver = "ESRI Shapefile")
```

```{r}
#THIS APPEARS TO WORK...NEED TO DROP CRUMBS
plot(st_geometry(kern_19_crop), main = "2019")
plot(st_geometry(kern_18_crop), main = "2018")
plot(st_geometry(stamp_test_sf), main = "Stamp_test")

library(tmap)

tmap_mode("view")

tm_shape(stamp_test_sf) +
tm_polygons("GROUP")
```

STAMP interp

ID1 Polygon ID from T1 polygons; NA if it did not exist,
ID2 Polygon ID from T2 polygons; NA if it did not exist,
LEV1 Level 1 STAMP designation,
LEV2 Level 2 STAMP designation,
LEV3 Level 3 STAMP designation,
LEV4 Level 4 STAMP designation,
GROUP Group ID signifying group membership,
AREA Polygon area in appropriate areal units,
-- (optional) Additional columns from directional analysis if direction = TRUE,
-- (optional) Additional columns from distance analysis if distance = TRUE,


STAMP events are reported at four levels of increasing complexity:
LEV1 – disappearance (DISA), stable (STBL), and generation (GENA);
LEV2 – disappearance (DISA), contraction (CONT), stable (STBL), expansion (EXPN), and generation
(GENR);
LEV3 – disappearance (DISA), T1 displacement (DISP1), convergence (CONV), concentration (CONC),
contraction (CONT), stable (STBL), expansion (EXP), fragmentation (FRAG), divergence (DIV), T2 displacement (DISP2), and generation (GENR);
LEV4 – LEV4 is different from other levels. It is used to identify those groups where union (UNION),
division (DIVISION), and both union and division (BOTH) events occur. 




